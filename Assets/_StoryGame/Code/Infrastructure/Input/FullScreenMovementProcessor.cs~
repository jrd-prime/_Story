using _StoryGame.Infrastructure.Input.Interfaces;
using _StoryGame.Infrastructure.Logging;
using R3;
using UnityEngine;
using UnityEngine.UIElements;
using VContainer.Unity;

namespace _StoryGame.Infrastructure.Input
{
    public sealed class FullScreenMovementProcessor : IInitializable
    {
        public ReactiveProperty<Vector3> MoveDirection { get; } = new(Vector3.zero);
        public ReactiveProperty<bool> IsTouchPositionVisible { get; } = new(false);
        public ReactiveProperty<Vector2> RingPosition { get; } = new(Vector2.zero);

        private readonly IJLog _log;
        private readonly IJInput _input;

        private bool _isTouchActive;
        private const float OffsetForFullSpeed = 100f;
        private Vector2 _startTouchPosition;
        private readonly CompositeDisposable _disposables = new();

        public FullScreenMovementProcessor(IJInput input, IJLog log)
        {
            (_input, _log) = (input, log);
            _log.Debug($"FullScreenMovementProcessor constructed. IJInput: {(_input != null ? "not null" : "null")}");
        }

        public void Initialize()
        {
            _log.Debug("Initializing FullScreenMovementProcessor");
            if (_input == null)
            {
                _log.Error("IJInput is null, cannot subscribe to input events");
                return;
            }

            _log.Debug("Subscribing to input events");
            _input.TouchBegan.Subscribe(OnTouchBegan).AddTo(_disposables);
            _input.TouchMoved.Subscribe(OnTouchMoved).AddTo(_disposables);
            _input.TouchEnded.Subscribe(OnTouchEnded).AddTo(_disposables);
            _log.Debug("Input events subscribed successfully");
        }

        private void OnTouchBegan(Vector2 position)
        {
            _log.Debug($"OnTouchBegan at position: {position}, isTouchActive: {_isTouchActive}");
            if (_isTouchActive)
            {
                _log.Debug("Touch is already active, ignoring");
                return;
            }

            // Проверяем, есть ли кнопка (VisualElement с pickingMode = Position) под кликом
            if (TryHandleButtonClick(position))
            {
                _log.Debug("Click handled by UI button, movement not started");
                return;
            }

            _log.Debug("No button clicked, starting joystick movement");
            _isTouchActive = true;
            _startTouchPosition = position;
            RingPosition.Value = position;
            IsTouchPositionVisible.Value = true;
            _log.Debug($"Joystick started. StartTouchPosition: {_startTouchPosition}, RingPosition: {RingPosition.Value}");
        }

        private void OnTouchEnded(Vector2 position)
        {
            _log.Debug($"OnTouchEnded at position: {position}, isTouchActive: {_isTouchActive}");
            _isTouchActive = false;
            MoveDirection.Value = Vector3.zero;
            IsTouchPositionVisible.Value = false;
            _log.Debug($"Joystick stopped. MoveDirection: {MoveDirection.Value}");
        }

        private void OnTouchMoved(Vector2 currentPosition)
        {
            _log.Debug($"OnTouchMoved at position: {currentPosition}, isTouchActive: {_isTouchActive}");
            if (!_isTouchActive)
            {
                _log.Debug("Touch is not active, ignoring movement");
                return;
            }

            var offset = currentPosition - _startTouchPosition;
            var distance = offset.magnitude;
            _log.Debug($"Joystick offset: {offset}, distance: {distance}");

            if (distance > OffsetForFullSpeed)
            {
                offset = offset.normalized * OffsetForFullSpeed;
                _log.Debug($"Distance exceeds OffsetForFullSpeed, normalized offset: {offset}");
            }

            var moveInput = offset / OffsetForFullSpeed;
            MoveDirection.Value = new Vector3(moveInput.x, 0, moveInput.y);
            _log.Debug($"MoveDirection updated: {MoveDirection.Value}");
        }

        private bool TryHandleButtonClick(Vector2 position)
        {
            _log.Debug($"TryHandleButtonClick at position: {position}");

            // Ищем первый активный UIDocument
            var uiDocument = Object.FindObjectOfType<UIDocument>();
            if (uiDocument == null)
            {
                _log.Warn("No UIDocument found in scene");
                return false;
            }

            _log.Debug($"Found UIDocument: {uiDocument.gameObject.name}");
            if (uiDocument.rootVisualElement == null)
            {
                _log.Error($"UIDocument {uiDocument.gameObject.name} has null rootVisualElement");
                return false;
            }

            var panel = uiDocument.rootVisualElement.panel;
            if (panel == null)
            {
                _log.Error($"UIDocument {uiDocument.gameObject.name} has null panel");
                return false;
            }

            // Конвертируем экранные координаты в координаты панели
            Vector2 panelPosition = RuntimePanelUtils.ScreenToPanel(panel, position);
            _log.Debug($"Screen position: {position}, Panel position: {panelPosition}");

            // Проверяем, есть ли VisualElement с pickingMode = Position под позицией
            VisualElement pickedElement = panel.Pick(panelPosition);
            if (pickedElement != null && pickedElement.pickingMode == PickingMode.Position)
            {
                _log.Debug($"Found button: {pickedElement.name} (pickingMode: {pickedElement.pickingMode})");
                // Отправляем событие клика
                using (var clickEvent = ClickEvent.GetPooled())
                {
                    clickEvent.target = pickedElement;
                    clickEvent.position.Set( panelPosition.x, panelPosition.y, 0);
                    pickedElement.SendEvent(clickEvent);
                    _log.Debug($"ClickEvent sent to button: {pickedElement.name}");
                }
                return true; // Клик обработан кнопкой
            }

            _log.Debug($"No button found. Picked: {(pickedElement != null ? $"{pickedElement.name} (pickingMode: {pickedElement.pickingMode})" : "null")}");
            return false;
        }

        public void Dispose()
        {
            _log.Debug("Disposing FullScreenMovementProcessor");
            _disposables.Dispose();
            _log.Debug("Disposables disposed");
        }
    }
}