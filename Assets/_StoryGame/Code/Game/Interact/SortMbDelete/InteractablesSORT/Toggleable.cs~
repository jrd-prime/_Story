using System;
using _StoryGame.Core.Interact.Enums;
using _StoryGame.Core.Managers;
using _StoryGame.Game.Interact.Abstract;
using _StoryGame.Game.Interact.Systems;
using _StoryGame.Game.Managers.Condition;
using Cysharp.Threading.Tasks;
using Sirenix.OdinInspector;
using UnityEngine;
using VContainer;

namespace _StoryGame.Game.Interact.InteractablesSORT.Condition
{
    /// <summary>
    /// Вода которую можно откачать. Веревка, которая сбрасывается в люк. Т.е. есть аним
    /// </summary>
    [RequireComponent(typeof(Animation))]
    public sealed class Toggleable : AConditional<ToggleSystem>, IToggleable
    {
        [Title(nameof(Toggleable), "Main", titleAlignment: TitleAlignments.Centered)] [SerializeField]
        private EToggleType toggleType = EToggleType.NotSet;

        [SerializeField] private ESwitchState defaultState = ESwitchState.NotSet;

        [ShowIf("@toggleType==EToggleType.Modifier")] [SerializeField]
        private EGlobalInteractCondition condition = EGlobalInteractCondition.NotSet;

        [Title(nameof(Toggleable), "Animation", titleAlignment: TitleAlignments.Centered)] [SerializeField]
        private AnimationClip onStateClip;

        [SerializeField] private AnimationClip offStateClip;

        public EToggleType ToggleType => toggleType;
        public ESwitchState SwitchState => _currentState;
        public EGlobalInteractCondition ImpactOnCondition => condition;

        private ESwitchState _currentState = ESwitchState.NotSet;
        private EConditionResult _conditionResult = EConditionResult.NotSet;
        private bool _isInitialized;
        private Animation _animation;
        private string _onClipName;
        private string _offClipName;
        private Collider[] _colliders;

        private const int SpeedMul = 20;

        protected override void OnAwake()
        {
            if (toggleType == EToggleType.NotSet)
                throw new Exception($"ToggleableType not set for {name}.");
            if (defaultState == ESwitchState.NotSet)
                throw new Exception(
                    $"ToggleableState not set for {name}. Please set defaultState (e.g., On for the puddle).");

            _animation = GetComponent<Animation>();

            if (!_animation)
                throw new Exception($"Animation component not found on {name}.");
            if (!onStateClip)
                throw new Exception($"ON State Animation Clip is not assigned for {name}.");
            if (!offStateClip)
                throw new Exception($"OFF State Animation Clip is not assigned for {name}.");

            _onClipName = onStateClip.name;
            _offClipName = offStateClip.name;

            if (_animation[onStateClip.name] == null)
                _animation.AddClip(onStateClip, _onClipName);

            if (_animation[offStateClip.name] == null)
                _animation.AddClip(offStateClip, _offClipName);

            AnimToOffState().Forget();

            _colliders = gameObject.GetComponents<Collider>();
            _isInitialized = true;
        }

        private async UniTask AnimToOffState()
        {
            LOG.Warn("AnimToOffState > OFF");
            var defSpeed = _animation[_offClipName].speed;
            _animation[_offClipName].speed = 1f * SpeedMul;
            _animation.Play(_offClipName);
            _currentState = ESwitchState.Off;

            await UniTask.Delay((int)(offStateClip.length * 1000) / SpeedMul);

            _animation[_offClipName].speed = defSpeed;
        }

        protected override void Enable()
        {
            if (!_isInitialized)
                throw new Exception("Toggleable is not initialized " + name);

            ConditionChecker = Resolver.Resolve<ConditionChecker>();

            if (ConditionChecker == null)
                throw new Exception($"ConditionChecker is null for {gameObject.name}.");

            var result = ConditionChecker.CheckConditions(ConditionsData).Success;
            _conditionResult = result ? EConditionResult.Fulfilled : EConditionResult.NotFulfilled;

            SwitchToggle(result);
        }

        private async void SwitchToggle(bool result)
        {
            var targetState = result ? GetOppositeState(defaultState) : defaultState;

            if (_currentState == targetState)
            {
                LOG.Info($"Состояние уже корректно: default={defaultState}, current={_currentState}");
                return;
            }

            LOG.Warn($"Меняем состояние: default={defaultState}, current={_currentState} -> target={targetState}");
            try
            {
                await AnimStateTo(targetState);
            }
            catch (Exception ex)
            {
                LOG.Error($"Ошибка при смене состояния на {targetState}: {ex.Message}");
            }
        }

        private static ESwitchState GetOppositeState(ESwitchState state) =>
            state == ESwitchState.Off ? ESwitchState.On : ESwitchState.Off;

        private async UniTask AnimStateTo(ESwitchState state)
        {
            if (state == ESwitchState.On)
                foreach (var coll in _colliders)
                    coll.enabled = true;

            _currentState = state;

            var clip = state switch
            {
                ESwitchState.On => onStateClip,
                ESwitchState.Off => offStateClip,
                ESwitchState.NotSet => throw new ArgumentOutOfRangeException(nameof(state), state, null),
                _ => throw new ArgumentOutOfRangeException(nameof(state), state, null)
            };

            var clipLength = clip.length;
            var delay = (int)(clipLength * 1000);
            _animation.Play(clip.name);

            await UniTask.Delay(delay);

            if (state == ESwitchState.Off)
                foreach (var coll in _colliders)
                    coll.enabled = false;
        }
    }
}
